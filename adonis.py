#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from re import S
from hooking.generate_hooking import hook
from octopus.arch.wasm.utils import extract_mapping
from octopus.arch.wasm.graph import *
from octopus.arch.wasm.utils import Configuration

import argparse
import sys
import gvar
import logging
import sys
import time
import timeout_decorator
import traceback

from octopus.syspath.trace_parser import *

sys.setrecursionlimit(2000)
# print(sys.getrecursionlimit())

# check whether the argument is positive
def check_not_neg(value):
    ivalue = int(value)
    if ivalue < 0:
        raise argparse.ArgumentTypeError("Random should be a positive number")
    return ivalue


def main():
    parser = argparse.ArgumentParser(
        description='Security Analysis tool for WebAssembly module and Blockchain Smart Contracts (BTC/ETH/NEO/EOS)')

    inputs = parser.add_argument_group('Input arguments')
    inputs.add_argument('-f', '--file',
                        type=argparse.FileType('rb'),
                        help='binary file (.wasm)',
                        metavar='WASMMODULE',
                        required=True)
    
    inputs.add_argument('-t', '--trace',
                        type=argparse.FileType('r'),
                        help='sysdig trace log',
                        metavar='SYSDIGLOG')
    
    inputs.add_argument('-b', '--batch',
                        type=str,
                        help='batch test',
                        metavar='SYSDIGLOGDIR')
    
    inputs.add_argument('-o', '--output',
                        type=str,
                        help='output dir',
                        metavar='OUTPUTDIR')
    
    inputs.add_argument('-c', '--cov',
                        type=str,
                        help='file to store the debug info (bb to code line)',
                        metavar='FILENAME',
                        required=False)
    
    inputs.add_argument('--func_hooking',
                        type=str,
                        help='path to store the function hooking info (generated by generated_hooking.py). Note: only used for function hooking.',
                        metavar='path_to_hooking_info',
                        required=False)
    
    inputs.add_argument('--log_trace',
                        action='store_true',
                        help='using log trace to recover control flow',
                        )

    features = parser.add_argument_group('Features')
    features.add_argument('-g', '--cfg',
                          action='store_true',
                          help='generate the control flow graph (CFG) (instruction level)')
    # features.add_argument('-c', '--call',
    #                       action='store_true',
    #                       help='generate the call flow graph (function level)')
    # features.add_argument('--need_mapper',
    #                       action='store_true',
    #                       help='give a mapping structure: func index to func name, e.g., {4: "$main"}')
    # features.add_argument('--random',
    #                       type=check_not_neg,
    #                       help='how many branches will be randomly selected in internal call instruction')
    # features.add_argument('--depth',
    #                       type=check_not_neg,
    #                       default=2,
    #                       help='how many layers of internal call')
    features.add_argument('--timeout',
                          type=check_not_neg,
                          default=5,
                          help='how many minutes can be endured when executing, default is 30')
    
    graph = parser.add_argument_group('Graph options')
    graph.add_argument('--functions', action='store_true',
                       help='create subgraph for each function')
    graph.add_argument('--onlyfunc', type=str,
                       nargs="*",
                       default=[],
                       help='only generate the CFG for this list of function name')
    graph.add_argument('-s', '--simplify', action='store_true',
                       help='simplify cfg when analyzing')

    args = parser.parse_args()

    octo_bytecode = None
    octo_cfg = None
    func_index2func_name = None
    hooking_type = "syscall"


    if not args.file:
        parser.print_help()


    
    if args.func_hooking:
        hooking_type = "function"
    elif args.log_trace:
        hooking_type = "log"
    else:
        hooking_type = "syscall"
        
    print("hooking type is: ", hooking_type)

    # process input file
    if args.file:
        # func_index2func_name is the func index to real func name
        # e.g., func 4 is $main, we have {4: '$main'}
        wat_file_path = args.file.name.replace('.wasm', '.wat')
        func_index2func_name = extract_mapping(wat_file_path)
        # print(func_index2func_name)

        if hooking_type == "syscall":
            api2trace_f = "adonis_res/simplified_api2trace.json"
        elif hooking_type == "function":
            api2trace_f = args.func_hooking
        elif hooking_type == "log":
            api2trace_f = "adonis_res/log_trace.json"
        print("read api2trace file from {}".format(api2trace_f))
        fp = open(api2trace_f, "r")
        import json
        api2trace = json.load(fp)

        octo_bytecode = args.file.read()

        from octopus.arch.wasm.cfg import WasmCFG
        from octopus.syspath.sys_graph import SysGraph

        print("build cfg...")
        octo_cfg = WasmCFG(octo_bytecode)
        octo_graph = SysGraph(octo_cfg, \
                                api2trace, \
                                func_index2func_name, \
                                only_func_name=args.onlyfunc, \
                                simplify=args.simplify)
        octo_graph.set_entry_function_names(["main"])
        if args.cov:
            octo_graph.init_coverage(args.cov)
        if octo_graph.simplify:
            octo_graph.simplify_cfg()

    # visualize syscall in CFG
    if args.cfg and args.onlyfunc:
        octo_graph.view_functions(args.onlyfunc)
        exit(0)
    
    if args.output:
        output_dir = args.output
    else:
        output_dir = "default_output_dir"
    
    if args.trace:
        if hooking_type == "syscall":
            event_trace = sysdig_log2event_trace(args.trace.name)
        elif hooking_type == "function":
            event_trace = function_hooking_log_2event_trace(args.trace.name)
        elif hooking_type == "log" :
            event_trace = function_hooking_log_2event_trace(args.trace.name)
            event_trace = retain_log(event_trace)
        if args.cov:
            cal_cov = True
        else:
            cal_cov = False
        octo_graph.solve(event_trace, cal_cov, output_dir)

    if args.batch:
        traces = os.listdir(args.batch)
        traces = sorted(traces)
        solved = 0
        tot = 0
        st = time.time()
        for trace in traces:
            print("test case:", trace)
            tot += 1
            try:
                solved += test(octo_graph, trace, args, hooking_type)
            except timeout_decorator.timeout_decorator.TimeoutError:
                print("time out!")
        et = time.time()
        print("{}/{} solved".format(solved, tot))
        print("time used: {}s".format(et-st))


@timeout_decorator.timeout(1200)
def test(graph, trace, args, hooking_type):
    try:
        if hooking_type == "syscall":
            event_trace = sysdig_log2event_trace(os.path.join(args.batch, trace))
        elif hooking_type == "function":
            event_trace = function_hooking_log_2event_trace(os.path.join(args.batch, trace))
        elif hooking_type == "log" :
            event_trace = function_hooking_log_2event_trace(os.path.join(args.batch, trace))
            event_trace = retain_log(event_trace)
        if args.cov:
            cal_cov = True
        else:
            cal_cov = False
        if args.output:
            output_dir = os.path.join(args.output, trace.split(".")[0])
        else:
            output_dir = os.path.join("default_output_dir", trace.split(".")[0])
        return graph.solve(event_trace, cal_cov, output_dir)
    except timeout_decorator.timeout_decorator.TimeoutError:
        raise timeout_decorator.timeout_decorator.TimeoutError
    except KeyboardInterrupt:
        raise KeyboardInterrupt
    # except Exception as e:
    #     print(e)
    #     traceback.print_stack()
    #     return 0
        

if __name__ == '__main__':
    main()
