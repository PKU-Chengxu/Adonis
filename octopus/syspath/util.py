from collections import defaultdict
from graphviz import Digraph
from octopus.syspath.path import Path
from octopus.analysis.graph import Graph
from octopus.syspath.execution_path import ExecutionPathNode, GeneralExecutionPathNode

from octopus.core.edge \
    import (EDGE_UNCONDITIONAL,
            EDGE_CONDITIONAL_TRUE, EDGE_CONDITIONAL_FALSE,
            EDGE_FALLTHROUGH, EDGE_CALL, Edge)

MAX_PATH_NUM = int(1000) # max num of paths we traverse in each function


####### Below is the functions related to EPP algorithm #######   
def construct_syscall_trace(func, bb2api):
    """
    Construct syscall trace for func.
    Refer to Ball & Larus Path Profiling Algorithm.
    Also refer to https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/efficient-path-prof/
    """

    # 1. identify entry and exit
    entry_bb = func.basicblocks[0]
    exit_bb = func.basicblocks[-1]
    # assert len(entry_bb.pred_bbs) == 0 and len(exit_bb.succ_bbs) == 0

    # 2. for each back edge, remove it from cfg and add two vitual edges
    g_minus_back_plus_loop = Graph([bb.name for bb in func.basicblocks], [])
    g_minus_back_plus_loop.entry = entry_bb.name
    g_minus_back_plus_loop.exit = exit_bb.name
    # the addition edges will make some edges have from node and to node
    # we shall distinguish them
    index = 0 
    func.backedges = []
    for edge in func.edges:
        if is_back_edge(edge):
            func.backedges.append(edge.to_string())
            entry_to_head = Edge(entry_bb.name, edge.node_to, EDGE_VIRTUAL)
            entry_to_head.back_edge_entry_mapping = edge
            entry_to_head.index = index
            index += 1
            g_minus_back_plus_loop.edges.append(entry_to_head)
            
            tail_to_exit = Edge(edge.node_from, exit_bb.name, EDGE_VIRTUAL)
            tail_to_exit.back_edge_exit_mapping = edge
            tail_to_exit.index = index
            index += 1
            g_minus_back_plus_loop.edges.append(tail_to_exit)
        else:
            g_minus_back_plus_loop.edges.append(edge)
    
    # 3. compute Val(e) and NumPaths(v)
    reverse_topology = DFSTraverse(g_minus_back_plus_loop)
    print(reverse_topology)
    NumPaths = {}
    Val = {}
    for v in reverse_topology:
        edges_from_v = [e for e in g_minus_back_plus_loop.edges if e.node_from == v]
        if len(edges_from_v) == 0:
            NumPaths[v] = 1
        else:
            NumPaths[v] = 0
            for e in edges_from_v:
                Val[e.to_string()] = NumPaths[v]
                NumPaths[v] += NumPaths[e.node_to]
    
    path_num = NumPaths[g_minus_back_plus_loop.entry]
    print("total path num: {}".format(path_num))
    g_minus_back_plus_loop.Val = Val # save the val assignment in the graph
    func.g_minus_back_plus_loop = g_minus_back_plus_loop
    
    # 3. generate paths
    paths = []
    func.api2pathSum = defaultdict(list)
    func.path_start_from_entry = []
    func.path_end_at_exit = []
    if path_num > MAX_PATH_NUM:
        print("[WARN] function ({}) exceed max num of paths, we will not use EPP algo".format(func.name))
        return
    else:
        pathSums = range(path_num)
    for i in pathSums:
        p = Path(i, g_minus_back_plus_loop)
        path = p.real_path()
        if p.start_from_entry:
            func.path_start_from_entry.append(i)
        if p.end_at_exit:
            func.path_end_at_exit.append(i)
        paths.append(p)
        api_trace = []
        for bb in path:
            api = bb2api[bb]
            api_trace += api
        func.api2pathSum[str(api_trace)].append(i)
    print("api => pathSum")
    for k in func.api2pathSum:
        print(k, "=>" , func.api2pathSum[k])
    
    # Paths generated by EPP algorithm may be not the full path (strat from entry and end at exit).
    # To be more specific, paths that contain virtual edge is partial part of the full path. 
    # We use a dict to store which partial path can connect with another.
    # For example. Path(1) is a partial path that starts from entry and ends at bb_A, Path(4) is a partial
    # path that strats at bb_B and ends at bb_C, Path(6) is a partial path that strats at bb_C and ends at exit,
    # and we have backedges (bb_A->bb_B) (bb_A->bb_C), then we should store {1: [4,6]}, which means path(1) can
    # connect with path(4) and path(6).
    func.path_connector = defaultdict(list)
    func.reverse_path_connector = defaultdict(list)
    for edge in func.backedges:
        f,t = edge.split("->")
        paths_end_at_from = []
        paths_start_at_to = []
        for path in paths:
            if path.end_node == f:
                paths_end_at_from.append(path.pathSum)
            if path.start_node == t:
                paths_start_at_to.append(path.pathSum)
        for pathSum in paths_end_at_from:
            func.path_connector[str(pathSum)].extend(paths_start_at_to)
        for pathSum in paths_start_at_to:
            func.reverse_path_connector[str(pathSum)].extend(paths_end_at_from)
    """
    if func.path_connector:
        print("partial path connection info:")
        for k in func.path_connector:
            print("pathSum({}): {}".format(k, func.path_connector[k]))
    if func.reverse_path_connector:
        print("partial path connection info (reverse):")
        for k in func.reverse_path_connector:
            print("pathSum({}): {}".format(k, func.reverse_path_connector[k]))
    """

# add a new member function to Function class
from octopus.core.function import Function
Function.construct_syscall_trace = construct_syscall_trace


visited = {}
def DFSTraverse(G):
    """
    return reverse topology sort of vertices in G
    """
    global visited
    visited = { bb: False for bb in G.basicblocks }
    reverse_topology = []
    for v in G.basicblocks:
        if not visited[v]:
            reverse_topology.extend(DFS(G, v))
    return reverse_topology


def DFS(G, v):
    global visited
    visited[v] = True
    res = []
    for e in G.edges:
        if e.node_from == v and not visited[e.node_to]:
            res.extend(DFS(G, e.node_to))
    res.append(v)
    return res


def epp_search(func, api, to_match, legal_pathSum = None, start_from_entry = True, end_at_exit = True):
    """
    search paths that contain api and (partially) match the to_match
    trace (i.e., allowing some heading and tailing apis are left unmatched, 
    which might get matched in other function).
    We leverage the EPP algorithm to accelerate.
    Args:
    legal_pathSum - legal pathSum. if legal_pathSum is None, all the pathSum is legal.
    legal_pathSum != None means we are connecting the loop
    start_from_exit - whether path should start from entry
    end_at_exit - whether path should end at exit
    return path and matched api.
    """
    paths = []
    for api_trace_string in func.api2pathSum:
        api_trace = build_api_trace_from_string(api_trace_string)
        if seems_find_a_path(api, legal_pathSum, api_trace):
            candi_pathSums = func.api2pathSum[api_trace_string]
            # filter the legal pathSum
            if legal_pathSum == None:
                pathSums = candi_pathSums
            else:
                pathSums = [pathSum for pathSum in candi_pathSums if pathSum in legal_pathSum]
            if pathSums == []:
                continue

            # try to match
            if start_from_entry and end_at_exit:
                # api_trace contains position while to_match does not.
                match_start_at = trace_contain(to_match, api_trace)
            elif not start_from_entry and end_at_exit:
                # match at the begin of 'to_match'
                match_start_at = match_from_head(to_match, api_trace)
            elif start_from_entry and not end_at_exit:
                # match from the end of 'to_match'
                match_start_at = match_from_tail(to_match, api_trace)
            
            if match_start_at == -1 and contain_func_call(api_trace):
                continue
                # raise NotImplementedError # TODO

            if match_start_at == -1: # not match
                continue
            else: # find a match
                matched = to_match[match_start_at:match_start_at+len(api_trace)]
                for pathSum in pathSums:
                    if (pathSum in func.path_start_from_entry or start_from_entry==False) \
                        and (pathSum in func.path_end_at_exit or end_at_exit==False):
                        epn = ExecutionPathNode(func)
                        epn.add_path_tail(pathSum)
                        epn.add_api_tail(matched)
                        epn.set_match_start_at(match_start_at)
                        paths.append(epn)
                    elif (pathSum in func.path_start_from_entry or start_from_entry==False) \
                        and not (pathSum in func.path_end_at_exit or end_at_exit==False):
                        # start from entry but not end at exit
                        legel_pathSum_after_matched = func.path_connector[str(pathSum)]
                        left_to_match = to_match[match_start_at+len(api_trace):]
                        if left_to_match == []:
                            continue
                        succ_paths = []
                        for _ in left_to_match[0]:
                            succ_paths += epp_search(func, 
                                                            _, 
                                                            left_to_match, 
                                                            legel_pathSum_after_matched,
                                                            start_from_entry = False,
                                                            end_at_exit = end_at_exit)
                        for succ_path in succ_paths:
                            epn = ExecutionPathNode(func)
                            epn.add_path_tail(pathSum)
                            epn.add_api_tail(matched)
                            epn.set_match_start_at(match_start_at)
                            epn.merge_tail(succ_path)
                            paths.append(epn)
                    elif not (pathSum in func.path_start_from_entry or start_from_entry==False) \
                        and (pathSum in func.path_end_at_exit or end_at_exit==False):
                        # end at exit but not start from entry
                        legel_pathSum_after_matched = func.reverse_path_connector[str(pathSum)]
                        left_to_match = to_match[:match_start_at]
                        if left_to_match == []:
                            continue
                        pred_paths = []
                        for _ in left_to_match[-1]:
                            pred_paths += epp_search(func, 
                                                            _,
                                                            left_to_match, 
                                                            legel_pathSum_after_matched,
                                                            start_from_entry = start_from_entry,
                                                            end_at_exit = False)
                        for pred_path in pred_paths:
                            epn = ExecutionPathNode(func)
                            epn.add_path_tail(pathSum)
                            epn.add_api_tail(matched)
                            epn.merge_head(pred_path)
                            paths.append(epn)
                    else:
                        # neither start from entry nor end at exit
                        legel_pathSum_after_matched = func.path_connector[str(pathSum)]
                        left_to_match = to_match[match_start_at+len(api_trace):]
                        if left_to_match == []:
                            continue
                        succ_paths = []
                        for _ in left_to_match[0]:
                            succ_paths += epp_search(func, 
                                                            _, 
                                                            left_to_match, 
                                                            legel_pathSum_after_matched,
                                                            start_from_entry = False,
                                                            end_at_exit = end_at_exit)
                        legel_pathSum_after_matched = func.reverse_path_connector[str(pathSum)]
                        left_to_match = to_match[:match_start_at]
                        if left_to_match == []:
                            continue
                        pred_paths = []
                        for _ in left_to_match[-1]:
                            pred_paths += epp_search(func, 
                                                            _, 
                                                            left_to_match, 
                                                            legel_pathSum_after_matched,
                                                            start_from_entry = start_from_entry,
                                                            end_at_exit = False)
                        for succ_path in succ_paths:
                            for pred_path in pred_paths:
                                epn = ExecutionPathNode(func)
                                epn.add_path_tail(pathSum)
                                epn.add_api_tail(matched)
                                epn.merge_head(pred_path)
                                epn.merge_tail(succ_paths)
                                paths.append(epn)

    return paths


####### Below is the utility functions #######   
def is_back_edge(edge):
    if edge.node_from == "entry" or edge.node_to == "exit":
        return False
    f_num_str = edge.node_from.split("_")[-1]
    t_num_str = edge.node_to.split("_")[-1]
    f_num = int(f_num_str, 16)
    t_num = int(t_num_str, 16)
    return f_num >= t_num


def find_most_possible_api(apis):
    max_possibility = -1000
    res = []
    for _ in apis:
        for api in _:
            if api.possibility > max_possibility:
                max_possibility = api.possibility
    if max_possibility <= 50:
        # according to our exp, these apis are not suitable for expand from
        return res
    for _ in apis:
        for api in _:
            if api.possibility == max_possibility:
                res.append(api)
    return res


def find_most_possible_lib_api(apis, exclude_apis = []):
    max_possibility = -1000
    res = []
    for _ in apis:
        for api in _:
            if api in exclude_apis:
                continue
            if api.possibility > max_possibility:
                max_possibility = api.possibility
    if max_possibility <= 50:
        # according to our exp, these apis are not suitable for expand from
        return res
    for _ in apis:
        for api in _:
            if api in exclude_apis:
                continue
            if api.possibility == max_possibility:
                res.append(api)
    return res


def get_callee_index(inst):
    callee_str = inst.operand_interpretation.split()[-1]
    if "0x" in callee_str:
        return int(callee_str, 16)
    else:
        return int(callee_str)


def get_indirect_callee_type(inst):
    # for the call_indirect instruction, type is stored in its second byte
    return int(inst.bytes.encode()[1])


def get_func_index_by_inst_position(position):
    return int(position.split("_")[1], 16)


def build_api_trace_from_string(api_trace_string: str):
    api_trace_string = api_trace_string[1:-1]
    api_trace = []
    api_string_list = api_trace_string.split(",")
    for api_string in api_string_list:
        if api_string == '':
            continue
        api_string = api_string.strip()[1:-1]
        name, position = api_string.split("@")
        api_trace.append(API(name, position))
    return api_trace


def contain_func_call(api_list, exclude_func_name = []):
    # test if api list contain fuction call
    for api in api_list:
        if "$" in api.name and api.name not in exclude_func_name:
            return True
    return False


def loose_in(api, api_list):
    # test if api in api list (using loose equal)
    for _ in api_list:
        if api.name == _.name:
            return True
    return False


def seems_find_a_path(api, legal_pathSum, api_trace):
    if api.position: # api have the precise location
        return api in api_trace
    if legal_pathSum: # loop connection
        return api.name in [tapi.name for tapi in api_trace]
    assert False


def trace_contain(api_trace_a, api_trace_b):
    """
    test if api trace a contains api trace b
    using kmp algorithm
    return -1 for unmatched, or i for matched index i in trace a
    Note: api_trace_b contains position info while api_trace_a may not, so we should
    slightly modify the equal rule. see more details in syscall_api.py
    """
    la = len(api_trace_a)
    lb = len(api_trace_b)
    if la < lb:
        return -1
    # calculate next
    i = 0
    j = -1
    next = [-1] * len(api_trace_b)
    while i < len(api_trace_b)-1:
        if j == -1 or api_trace_b[i] == api_trace_b[j]: # for next, we use __eq__
            i += 1
            j += 1
            # next[i] = j
            if i < len(api_trace_b) and api_trace_b[i] != api_trace_b[j]: # for next, we use __eq__
                next[i] = j
            else:
                next[i] = next[j]
        else:
            j = next[j]
    # kmp
    i = 0
    j = 0

    def list_contain_api(possible_apis, api):
        for _ in possible_apis:
            if _.loose_equal(api):
                return True
        return False

    while i < len(api_trace_a) and j < len(api_trace_b):
        if j == -1 or list_contain_api(api_trace_a[i], api_trace_b[j]): # when compare a and b, we use loose_equal
            i += 1
            j += 1
        else:
            j = next[j]
    if j == len(api_trace_b):
        return i - j
    else:
        return -1


def match_from_head(api_trace_a, api_trace_b):
    """
    test if api trace a contains api trace b (must start matching from the beginning of a)
    return -1 for unmatched, or i for matched index i in trace a
    """
    la = len(api_trace_a)
    lb = len(api_trace_b)
    if la < lb:
        return -1
    i = 0
    
    def list_contain_api(possible_apis, api):
        for _ in possible_apis:
            if _.loose_equal(api):
                return True
        return False

    for i in range(lb):
        if not list_contain_api(api_trace_a[i], api_trace_b[i]):
            return -1
    return 0
        

def match_from_tail(api_trace_a, api_trace_b):
    """
    test if api trace a contains api trace b (must matching the end of a)
    return -1 for unmatched, or i for matched index i in trace a
    """
    la = len(api_trace_a)
    lb = len(api_trace_b)
    if la < lb:
        return -1
    i = 0

    def list_contain_api(possible_apis, api):
        for _ in possible_apis:
            if _.loose_equal(api):
                return True
        return False

    for i in range(lb):
        if not list_contain_api(api_trace_a[-i-1], api_trace_b[-i-1]):
            return -1
    return la-lb


def render(func, file_name, bb2api):
    g = Digraph('G', filename=file_name)
    g.attr(rankdir='TB')
    g.attr(overlap='scale')
    g.attr(splines='polyline')
    g.attr(ratio='fill')

    design = {'shape': 'box', 'fontname': 'Courier', 'fontsize': '30.0', 'rank': 'same'}
    with g.subgraph(name=file_name, node_attr=design) as c:
        if func.name == func.prefered_name:
            name = func.name
        else:
            name = func.prefered_name + ' - ' + func.name
        c.attr(label=name)
        c.attr(color='gray')
        c.attr(fontsize='50.0')
        c.attr(overlap='false')
        c.attr(splines='polyline')
        c.attr(ratio='fill')

        # create all the basicblocks (blocks)
        for basicblock in func.basicblocks:
            if bb2api[basicblock.name] != []:
                c.node(basicblock.name, label=basicblock.name + "\n" + str(bb2api[basicblock.name]), splines='true', fontcolor="red")
            else:
                c.node(basicblock.name, label=basicblock.name, splines='true')

    edges = func.edges
    from octopus.analysis.graph import insert_edges_to_graph
    insert_edges_to_graph(g, edges)

    print("writing to", file_name)
    g.render(file_name, view=False)


def get_inst_offset_in_position(position):
    return int(position.split("#")[-1])


def get_function_index_by_name(function_name):
    if "$" in function_name:
        return int(function_name[5:])
    else:
        return -1


def get_index_in_cfg_by_function_index(cfg, function_index):
    """
    For a function, its function index (index in the name, like $func35) is
    different from its index in cfg (23th function in cfg). This function is
    for the translation from function index to the index in cfg.
    """
    for i in range(len(cfg.functions)):
        f = cfg.functions[i]
        f_func_index = get_function_index_by_name(f.name)
        if function_index == f_func_index:
            return i
    raise ValueError("Cannot find a function with the func index of {}".format(function_index))


def dump_merge_log(file_name, log):
    print("merge log write to", file_name)
    fp = open(file_name, "w")
    for _ in log:
        fp.write(_ + "\n")
    fp.close()


def assign_trace_to_checkpoint(ckpts, traces):
    # note that traces have been wrapped as apis, we should unwrap them to trace
    unwrapped_traces = []
    for api in traces:
        # each possible api have the same trace, so we just need the first one
        unwrapped_traces.append(api[0].trace)
    if len(unwrapped_traces) == len(ckpts):
        for i in range(len(unwrapped_traces)):
            ckpts[i].trace = [unwrapped_traces[i]]
    elif len(unwrapped_traces) > len(ckpts) and len(ckpts) == 1:
        ckpts[0].trace = unwrapped_traces
    else:
        assert False
    return ckpts