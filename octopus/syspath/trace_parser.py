from collections import defaultdict
import json
import argparse

from octopus.syspath.event import build_from_log

default_input = "trace.txt"
default_output = "parsed_trace.json"


def WARN(s):
    print("[WARN] {}".format(s))

def ERROR(s):
    print("[ERROR] {}".format(s))

def INFO(s):
    print("[INFO] {}".format(s))

def DEBUG(s):
    print("[DEBUG] {}".format(s))


def get_trace_id(l):
    return l.split()[0]


def get_timestamp(l):
    return l.split()[1]


def get_cpu_id(l):
    return l.split()[2]


def get_proc_name(l):
    return l.split()[3]


def get_tid(l):
    return l.split()[4]


def get_direction(l):
    return l.split()[5]


def get_event_type(l):
    return l.split()[6]


def get_event_args_str(l):
    items = l.split()
    event_args = ""
    if len(items) > 7:
        event_args = " ".join(items[7:])
    return event_args


def get_api_name(l):
    event_args = get_event_args_str(l)
    li = event_args.find("<")
    ri = event_args.find(">")
    return event_args[li+1:ri]

def trace_template(args):
    temp = {"args": args, "trace": [], "return": ""}
    return temp

def sysdig_log2event_trace(log_file):
    """
    parse a sysdig log, and return all possible api call traces
    """
    fp = open(log_file, "r")
    lines = fp.readlines()

    enter_main = False # if it enters the main function
    event_trace = []

    for i in range(len(lines)):
        l = lines[i]
        # DEBUG(l)
        if i < len(lines) - 1:
            nl = lines[i+1] # next line
        else:
            nl = "7825386 08:27:09.824821639 0 helloworld (4015005) > procexit status=0" # a fake trace

        # ignore switch
        try:
            l_event_type = get_event_type(l)
            nl_event_type = get_event_type(nl)
        except IndexError:
            continue
        if l_event_type == "switch":
            continue
        if nl_event_type == "switch":
            try:
                nl = lines[i+2]
            except IndexError:
                break
        
        l_event_type = get_event_type(l)
        nl_event_type = get_event_type(nl)
        l_direction = get_direction(l)
        nl_direction = get_direction(nl)
        l_proc_name = get_proc_name(l)

        # program entry point and exit point
        if not enter_main:
            if l_event_type == "munmap" and l_direction == "<":
                enter_main = True
                continue
            else:
                continue
        
        if enter_main:
            # exit point
            if l_event_type == "procexit":
                enter_main = False
                continue
            if l_direction == ">" and nl_direction == "<" and \
                l_event_type == nl_event_type:
                event = build_from_log(l, nl)
                event_trace.append(event)
            
    print("parsed event trace:")
    print(event_trace)

    return event_trace


def function_hooking_log_2event_trace(log_file):
    fp = open(log_file, "r")
    raw = fp.read().split("$")
    raw_after_trim = []
    i = 0
    cur = ""
    while i < len(raw):
        cur += raw[i]
        if "((" in cur and "))" in cur:
            raw_after_trim.append(cur)
            cur = ""
        i += 1
    if "((" in cur and "))" in cur:
        raw_after_trim.append(cur)
        cur = ""
    event_trace = []
    for item in raw_after_trim:
        from octopus.syspath.event import build_from_function_hooking_log
        e = build_from_function_hooking_log(item)
        if e != None:
            event_trace.append(e)
    return event_trace


if __name__ == "__main__":
    """
    this is for parsing trace generated by programs using hooked libc api
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', type=str, dest="input", default=default_input, help="input trace file's path")
    parser.add_argument('-o', '--output', type=str, dest="output", default=default_output, help="output file's path")
    args = parser.parse_args()

    fp = open(args.input, "r")
    lines = fp.readlines()

    # print("last 6 lines:")
    # print(lines[-6:])

    execution_num = 0
    enter_main = False # if it enters the main function
    hook_api = ""  # "" for unhooked currently, and "func" for hooking the api named with func
    api2trace = {}
    current_trace = []
    for i in range(len(lines)):
        
        l = lines[i]
        # DEBUG(l)
        if i < len(lines) - 1:
            nl = lines[i+1] # next line
        else:
            nl = "7825386 08:27:09.824821639 0 helloworld (4015005) > procexit status=0" # a fake trace


        # ignore switch
        try:
            l_event_type = get_event_type(l)
            nl_event_type = get_event_type(nl)
        except IndexError:
            continue
        if l_event_type == "switch":
            continue
        if nl_event_type == "switch":
            nl = lines[i+2]

        # current line and next line
        try:
            l_event_type = get_event_type(l)
            nl_event_type = get_event_type(nl)
            l_direction = get_direction(l)
            nl_direction = get_direction(nl)
            l_proc_name = get_proc_name(l)
            if l_proc_name != "allfile":
                continue
        except IndexError:
            continue

        # program entry point and exit point
        if not enter_main:
            if l_event_type == "execve":
                execution_num += 1
            if l_event_type == "munmap" and l_direction == "<":
                enter_main = True
                continue
            else:
                continue
        
        if enter_main:
            # exit point
            if l_event_type == "procexit":
                enter_main = False
                continue

            # ignore openat of the hooking output
            if nl_event_type == "openat" and nl_direction == "<" and "hooking.out" in nl:
                continue
            if l_event_type == "openat" and l_direction == "<" and "hooking.out" in l:
                continue

            # start of hooking an api
            if nl_event_type == "write" and nl_direction == "<" and "> begins:$" in nl:
                continue 
            if l_event_type == "write" and l_direction == "<" and "> begins:$" in l:
                api_name = get_api_name(l)
                if hook_api == "":
                    hook_api = api_name
                    if hook_api not in api2trace:
                        api2trace[hook_api] = []
                        trace = trace_template(get_event_args_str(l))
                        api2trace[hook_api].append(trace)
                    else:
                        trace = trace_template(get_event_args_str(l))
                        api2trace[hook_api].append(trace)
                    continue
                else:
                    ERROR("nested hook???")
                    ERROR("current line: {}".format(l))
                    assert False
            
            # end of hooking an api
            if nl_event_type == "write" and nl_direction == "<" and "> ends:" in nl:
                continue
            if l_event_type == "write" and l_direction == "<" and "> ends:" in l:
                api_name = get_api_name(l)
                if hook_api != api_name:
                    ERROR("nested hook???")
                    ERROR("current line: {}".format(l))
                    assert False
                else:
                    trace_i = len(api2trace[hook_api]) - 1
                    api2trace[hook_api][trace_i]["trace"] = current_trace
                    current_trace = []
                    hook_api = ""
                    continue
                    

            # hooked api
            if hook_api != "":
                # tl = " ".join(l.split()[5:])
                current_trace.append(l)
            # unhooked api
            else:
                WARN("caught unhooked trace: {}".format(l))
                continue
            
            # unexpected events
            # here we assume that event "in" should be closely followed by event "out"
            if l_direction == ">":
                if nl_direction == ">" or l_event_type != nl_event_type:
                    if l_event_type not in ["execve", "exit_group", "procexit"]:
                        WARN("unexpected events: {}".format(l))

    
    INFO("num of execution: {}".format(execution_num))
    
    # post process to simplify
    new_api2trace = {}
    for api in api2trace:
        old_trace = api2trace[api]
        new_trace = []
        for old_item in old_trace:
            simplified_trace = "" # only syscall name is left
            for i in range(0, len(old_item["trace"]), 2):
                l = old_item["trace"][i]
                event_type = get_event_type(l)
                simplified_trace += "{}$".format(event_type)
            if simplified_trace not in new_trace:
                new_trace.append(simplified_trace)
        new_api2trace[api] = new_trace

    trace2api = {} # invert index
    for api in new_api2trace:
        for trace in new_api2trace[api]:
            trace = trace[:-1]
            if trace not in trace2api:
                trace2api[trace] = []
            trace2api[trace].append(api)


        
    INFO("saving parsed trace at {}".format(args.output))
    fp = open(args.output, "w")
    json.dump(api2trace, fp, indent=2)
    fp.close()
    fp = open("simplified_api2trace.json", "w")
    json.dump(new_api2trace, fp, indent=2)
    fp.close()
    fp = open("trace2api.json", "w")
    json.dump(trace2api, fp, indent=2)
    fp.close()


def retain_log(event_trace):
    log_apis = ["fprintf", "fputc", "fputs", "fwrite"]
    return [ e for e in event_trace if e.event_type in log_apis]