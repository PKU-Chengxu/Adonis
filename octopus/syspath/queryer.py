"""
This file contains the queryers of special functions.
A queryer recieves an api and an event trace as the input and return 
the possibility that the trace is generated by this api.
possibility is an int from 0 (impossible) to 100 (highest possible)
"""

import re
import Levenshtein

def printf_queryer(graph, api, event_trace):
    """
    for printf, we check the format string
    """
    if is_function_trace(event_trace):
        event_trace = event_trace[0]
        if event_trace.event_type == "putc" or event_trace.event_type == "putchar":
            arg_fmt_str = chr(int(event_trace.fields[0])).strip()
        elif event_trace.event_type == "puts":
            arg_fmt_str = event_trace.fields[0].strip()
        else:
            arg_fmt_str = event_trace.fields[0].strip()
        inst_hash = api.position
        if inst_hash not in graph.inst2fmtstr:
            print("Warn: cant find {} in inst2fmtstr".format(inst_hash))
            return 50 # we cannot determine
        fmtstr, regex = graph.inst2fmtstr[inst_hash]
        if arg_fmt_str == fmtstr:
            return 100
        return 0
    else:
        output_str = extract_output(event_trace)
        if output_str == None:
            return 0
        inst_hash = api.position
        if inst_hash not in graph.inst2fmtstr:
            print("Warn: cant find {} in inst2fmtstr".format(inst_hash))
            return 50 # we cannot determine
        fmtstr, regex = graph.inst2fmtstr[inst_hash]
        if fmt_match(regex, output_str):
            possibility = 100
            possibility -= int(100*distance(fmtstr, output_str)/len(output_str))
            if simple_format(fmtstr): # special panelty for simple format string like %s
                possibility -= 50
            return possibility
        return 0

def extract_output(event_trace):
    for e in event_trace:
        if e.event_type == "write":
            return e.fields["data"]

def fmt_match(regex: str, to_match: str):
    result = re.match(regex, to_match)
    if result:
        # print("True")
        return True
    # print("False")
    return False

def open_queryer(graph, api, event_trace):
    """
    for open, we check the mode and flag
    We note that the flag monitored by sysdig does not
    equal to the definition of linux system (open/fcntl).
    So we need to do some translation.
    """
    if is_function_trace(event_trace):
        event_trace = event_trace[0]
        mode = extract_mode_from_function(event_trace)
        flags = extract_flags_from_function(event_trace)
        inst_hash = api.position
        if inst_hash not in graph.inst2open_args:
            return 50
        args = graph.inst2open_args[inst_hash]
        t_mode = args["mode"]
        t_flags = args["flags"]
        if t_mode == mode and t_flags == flags:
            return 80
        return 20
    else:
        mode = extract_mode_from_syscall(event_trace)
        flags = extract_flags_from_syscall(event_trace)
        inst_hash = api.position
        if inst_hash not in graph.inst2open_args:
            return 50
        args = graph.inst2open_args[inst_hash]
        t_mode = args["mode"]
        t_flags = args["flags"]
        if t_mode == mode and t_flags == flags:
            return 80
        return 20
    

def extract_mode_from_syscall(event_trace):
    for e in event_trace:
        if e.event_type == "openat":
            break
    mode = int(e.fields["mode"], 8)
    return mode


def extract_mode_from_function(event_trace):
    mode = int(event_trace.fields[1])
    return mode


def extract_flags_from_function(event_trace):
    flags = int(event_trace.fields[2])
    return flags

# mapper from define string to value
# refer to fcntl-linux.h
define2value = {
        "O_ACCMODE": int("0003", 8),
        "O_RDONLY": int("00", 8),
        "O_WRONLY": int("01", 8),
        "O_RDWR": int("02", 8),
        "O_CREAT": int("0100", 8),
        "O_EXCL": int("0200", 8),
        "O_NOCTTY": int("0400", 8),
        "O_TRUNC": int("01000", 8),
        "O_APPEND": int("02000", 8),
        "O_NONBLOCK": int("04000", 8),
        "O_NDELAY": int("04000", 8),
        "O_SYNC": int("04010000", 8),
        "O_FSYNC": int("04010000", 8),
        "O_ASYNC": int("020000", 8),
        "__O_LARGEFILE": int("0100000", 8),
        "__O_DIRECTORY": int("0200000", 8),
        "__O_NOFOLLOW": int("0400000", 8),
        "__O_CLOEXEC": int("02000000", 8),
        "__O_DIRECT": int("040000", 8),
        "__O_NOATIME": int("01000000", 8),
        "__O_PATH": int("010000000", 8),
        "__O_DSYNC": int("010000", 8),
        "__O_TMPFILE": int("020200000", 8),
        "O_LARGEFILE": int("0100000", 8),
        "O_DIRECTORY": int("0200000", 8),
        "O_NOFOLLOW": int("0400000", 8),
        "O_CLOEXEC": int("02000000", 8),
        "O_DIRECT": int("040000", 8),
        "O_NOATIME": int("01000000", 8),
        "O_PATH": int("010000000", 8),
        "O_DSYNC": int("010000", 8),
        "O_TMPFILE": int("020200000", 8)
    }

def extract_flags_from_syscall(event_trace):
    for e in event_trace:
        if e.event_type == "openat":
            break
    flag_str = e.fields["flags"]
    l = flag_str.index("(")
    r = flag_str.index(")")
    define_str = flag_str[l+1:r]
    defines = define_str.split("|")
    flag_value = 0
    for define in defines:
        flag_value |= define2value[define]
    return flag_value


def fprintf_queryer(graph, api, event_trace):
    """
    for fprintf, we check the format string
    """
    if is_function_trace(event_trace):
        event_trace = event_trace[0]
        if event_trace.event_type == "fputc":
            arg_fmt_str = chr(int(event_trace.fields[0])).strip()
        elif event_trace.event_type == "fputs":
            arg_fmt_str = event_trace.fields[0].strip()
        elif event_trace.event_type == "fwrite":
            arg_fmt_str = event_trace.fields[0].strip()
        else:
            arg_fmt_str = event_trace.fields[1].strip()
        inst_hash = api.position
        if inst_hash not in graph.inst2ffmtstr:
            print("Warn: cant find {} in inst2fmtstr".format(inst_hash))
            return 50 # we cannot determine
        fmtstr, regex = graph.inst2ffmtstr[inst_hash]
        if arg_fmt_str == fmtstr:
            return 100
        return 0
    else:
        output_str = extract_output(event_trace)
        if output_str == None:
            return 0
        inst_hash = api.position
        if inst_hash not in graph.inst2ffmtstr:
            print("Warn: cant find {} in inst2ffmtstr".format(inst_hash))
            return 50 # we cannot determine
        fmtstr, regex = graph.inst2ffmtstr[inst_hash]
        if fmt_match(regex, output_str):
            possibility = 100
            # possibility -= int(100*distance(fmtstr, output_str)/len(output_str))
            possibility -= distance(fmtstr, output_str)
            if simple_format(fmtstr): # special panelty for simple format string like %s
                possibility -= 50
            return possibility
        return 0


def putc_queryer(graph, api, event_trace):
    return 1


def puts_queryer(graph, api, event_trace):
    return 1


def fputc_queryer(graph, api, event_trace):
    return 1


def fputs_queryer(graph, api, event_trace):
    return 1

def fwrite_queryer(graph, api, event_trace):
    return 1


def simple_format(format_str: str):
    """
    given a format string, if the string contains only one %s and the other chars' length
    is less than three, we consider it a simple format, which means it is too easy to
    match it with a given string.
    """
    num_of_s = len(re.findall(r"%s", format_str))
    return num_of_s in [1, 2] and len(format_str.replace(r"%s", "").replace("\n", "")) <= 3


def distance(str_1, str_2):
    # calculate edit distance between str_1 and str_2
    return Levenshtein.distance(str_1, str_2)


def is_function_trace(trace):
    if len(trace) == 1:
        for k in trace[0].fields.keys():
            if isinstance(k, int) or "ret" == k:
                return True
    return False